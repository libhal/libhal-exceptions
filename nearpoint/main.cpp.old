#include <algorithm>
#include <cstring>

#include <algorithm>
#include <format>
#include <fstream>
#include <span>
#include <string_view>
#include <vector>

#include <plugin-api.h>

// Plugin entry point - this function must exist
enum ld_plugin_status onload(struct ld_plugin_tv* tv);
namespace {
// Plugin version info
[[maybe_unused]] std::string_view const plugin_version = "1.0";

// Function to handle messages/logging
ld_plugin_message message_handler = nullptr;

template<class... Args>
void println(ld_plugin_level p_level, std::string_view p_format, Args... p_args)
{
  if (not message_handler) {
    return;
  }

  auto const log = std::vformat(p_format, std::make_format_args(p_args...));

  message_handler(p_level, log.c_str());
}

// All symbols read handler - called when all symbols are available
enum ld_plugin_status all_symbols_read_handler()
{
  println(LDPL_INFO, "All symbols have been read");

  return LDPS_OK;
}

// Cleanup handler - called at the end of linking
enum ld_plugin_status cleanup_handler()
{
  println(LDPL_INFO, "Plugin cleanup");
  return LDPS_OK;
}

struct function_info
{
  std::string name;
  std::string object_file;
  uint32_t address;
  uint32_t size;
  bool has_exception_info;

  // For sorting by size (smallest first for better nearpoint efficiency)
  bool operator<(function_info const& other) const
  {
    return size < other.size;
  }
};

std::vector<function_info> parse_exception_tables()
{
  // For now, return mock data
  // In reality, you'd use LDPT_GET_INPUT_SECTION_CONTENTS to parse
  // .ARM.exidx (ARM) or .eh_frame (x86) sections

  std::vector<function_info> functions = {
    { .name = "small_func",
      .object_file = "main.o",
      .address = 0x1000,
      .size = 32,
      .has_exception_info = true },
    { .name = "medium_func",
      .object_file = "main.o",
      .address = 0x1020,
      .size = 128,
      .has_exception_info = true },
    { .name = "large_func",
      .object_file = "main.o",
      .address = 0x10A0,
      .size = 512,
      .has_exception_info = true },
    { .name = "huge_func",
      .object_file = "main.o",
      .address = 0x12A0,
      .size = 1024,
      .has_exception_info = true },
  };

  // Sort by size for optimal nearpoint layout
  std::ranges::sort(functions);

  return functions;
}

bool check_if_sorted_by_size(std::span<function_info> p_functions)
{
  for (size_t i = 0; i < p_functions.size() - 1; ++i) {
    if (p_functions[i].has_exception_info &&
        p_functions[i + 1].has_exception_info) {
      if (p_functions[i].size > p_functions[i + 1].size) {
        return false;
      }
    }
  }
  return true;
}

void generate_extraction_and_reordering(std::span<function_info> functions)
{
  std::ofstream script("extract_and_order.ld");

  auto sorted_funcs = functions;
  std::ranges::sort(sorted_funcs);

  script << "SECTIONS {\n";
  script << "  .text.ordered : {\n";
  script << "    /* Extract and reorder exception functions */\n";

  for (auto const& func : sorted_funcs) {
    if (func.has_exception_info) {
      script << std::format("    *(.text.{})\n", func.name);
    }
  }

  script << "  }\n";
  script << "  \n";
  script << "}\n";

  // INSERT this right at the beginning of .text
  script << "INSERT BEFORE .text;\n";

  script.close();
}

}  // namespace

extern "C"
{

  // Main plugin entry point
  // NOLINTNEXTLINE(readability-identifier-naming)
  enum ld_plugin_status _onload(struct ld_plugin_tv* tv)
  {
    struct ld_plugin_tv* entry;
    ld_plugin_register_all_symbols_read register_all_symbols_read = nullptr;
    ld_plugin_register_cleanup register_cleanup = nullptr;

    // Parse the transfer vector to get linker interface functions
    for (entry = tv; entry->tv_tag != LDPT_NULL; ++entry) {
      switch (entry->tv_tag) {
        case LDPT_MESSAGE:
          message_handler = entry->tv_u.tv_message;
          break;
        case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
          register_all_symbols_read = entry->tv_u.tv_register_all_symbols_read;
          break;
        case LDPT_REGISTER_CLEANUP_HOOK:
          register_cleanup = entry->tv_u.tv_register_cleanup;
          break;
        case LDPT_API_VERSION:
          // Check API version compatibility
          if (entry->tv_u.tv_val != LD_PLUGIN_API_VERSION) {
            // TODO(kammce): make formatters for each of these
            println(LDPL_ERROR,
                    "API version mismatch: expected {}, got {}",
                    static_cast<int>(LD_PLUGIN_API_VERSION),
                    static_cast<int>(entry->tv_u.tv_val));
            return LDPS_ERR;
          }
          break;
        default:
          // Ignore unknown entries
          break;
      }
    }

    if (register_all_symbols_read) {
      register_all_symbols_read(all_symbols_read_handler);
    }

    if (register_cleanup) {
      register_cleanup(cleanup_handler);
    }

    println(LDPL_INFO, "Simple linker plugin loaded successfully");

    return LDPS_OK;
  }
}
